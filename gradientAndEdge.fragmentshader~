#version 300 es
precision highp float;

uniform highp float maxF;
uniform highp float minF;

in vec2 kernelCoordinate_0_y;
in vec2 kernelCoordinate_1;
in vec2 kernelCoordinate_2_y;
in vec2 kernelCoordinate_0_x;
in vec2 kernelCoordinate_2_x;

uniform sampler2D myTextureSampler;

uniform float convKernel_0;
uniform float convKernel_1;
uniform float convKernel_2;

const vec4 bitShInv = vec4( 1.0 / (256.0 * 256.0 * 256.0), 1.0 / (256.0 * 256.0), 1.0 / 256.0, 1.0); 
const vec4 bitSh = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );
const vec4 bitMsk = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );

vec4 Float2RGBA(float f)
{
   //f = (254.0/254.1211)*(f - floor(f/0.125)*0.125/255.0);
   f = ( f - minF ) / ( maxF - minF ) ;
   
   vec4 res = bitSh * f;
   vec4 tmp;
   res = fract( res );   
   //res -= res.xxyz * bitMsk;
   tmp.r = res.r - res.r*bitMsk.r;
   tmp.g = res.g - res.r*bitMsk.g;
   tmp.b = res.b - res.g*bitMsk.b;
   tmp.a = res.a  - res.b*bitMsk.a;
   
   res.x -= res.x*bitMsk.x;
   res.y -= res.x*bitMsk.y;
   res.z -= res.y*bitMsk.z;
   res.w -= res.z*bitMsk.w;

   return( tmp );
} 

float RGBA2Float( vec4 v ) //must call this to do computations
{
	float f = dot(v, bitShInv);
	f = f * (maxF - minF) + minF;
	return(f);
}



layout(location = 0) out vec4 edge;
layout(location = 1) out vec4 ux;
layout(location = 2) out vec4 uy;

void main()
{

	//note vec4 for RGBA format
	vec4 textureValue_0_y = round(texture( myTextureSampler, kernelCoordinate_0_y)*255.0)/256.0;
	vec4 textureValue_1   = round(texture( myTextureSampler, kernelCoordinate_1)*255.0)/256.0;
	vec4 textureValue_2_y = round(texture( myTextureSampler, kernelCoordinate_2_y)*255.0)/256.0;
	vec4 textureValue_0_x = round(texture( myTextureSampler, kernelCoordinate_0_x)*255.0)/256.0;
	vec4 textureValue_2_x = round(texture( myTextureSampler, kernelCoordinate_2_x)*255.0)/256.0;


	
    float  f0_y = RGBA2Float( textureValue_0_y );
    float  f1 = RGBA2Float( textureValue_1 );
	float  f2_y = RGBA2Float( textureValue_2_y );
	float  f0_x = RGBA2Float( textureValue_0_x );
	float  f2_x = RGBA2Float( textureValue_2_x );
	
	float fuy = f0_y*convKernel_0 + f1*convKernel_1 + f2_y*convKernel_2;
	float fux = f0_x*convKernel_0 + f1*convKernel_1 + f2_x*convKernel_2;

	
	fuy = fuy*256.0;//This value is 256 times smaller than in the matlab version, so to keep them the same multiply by 256 before nonlinear operations, then divide back                              
	fux = fux*256.0;
	
	float fJyy = fuy*fuy;
	float fJxx = fux*fux;
	float fJxy = fuy*fux;
	
	float fOut = sqrt(pow(fJxx-fJyy,2.0) + 4.0*pow(fJxy,2.0));
	float f3 = clamp( fOut/(256.0*8.0), minF, maxF);
	
	edge =  clamp(Float2RGBA( f3 ),0.0, 1.0 );
	ux =  Float2RGBA(fux/256.0);
	uy =  Float2RGBA(fuy/256.0);

}
